## 创建Java项目

1. IDEA新建---project---Java

   项目名和文件夹名相同

2. SRC目录下为java源代码，out目录默认为Java编译输出目录，*.java和public类名相同，一个\*.java文件下可以有多个class，但只有一个public类型class

## 局部变量

1. 局部变量，方法内的变量；
2. 局部变量不可以和方法形参同名，会报错
3. 局部变量和成员变量同名时，Java采取就近原则，局部变量近就使用局部变量

## 构造方法

1. 构造方法用来初始化实例，方法名与类名相同

2. 构造方法参数无限制，构造方法没有返回值（也没有void）

   ```java
   class Person{
       //创建构造方法
       public Person(){
           ...
       }
   }
   ```

3. 可以定义多个构造方法，通过new操作符调用时，编译器通过构造方法的参数数量、位置和类型自动区分

   ```java
   class Person {
       private String name;
       private int age;
   
       public Person(String name, int age) {
           this.name = name;
           this.age = age;
       }
   
       public Person(String name) {
           this.name = name;
           this.age = 12;
       }
   
       public Person() {
       }
   }
   ```

4. 一个构造方法可以调用其他构造方法，便于代码复用，语法是this(...):

   ```java
   class Person {
       private String name;
       private int age;
   
       public Person(String name, int age) {
           this.name = name;
           this.age = age;
       }
   
       public Person(String name) {
           this(name, 18); // 调用另一个构造方法Person(String, int)
       }
   
       public Person() {
           this("Unnamed"); // 调用另一个构造方法Person(String)
       }
   }
   ```

## 方法重载

1. 方法重载是指多个方法的方法名相同，但各自的参数不同；
2. 重载方法应该完成类似的功能，参考`String`的`indexOf()`；
3. 重载方法返回值类型应该相同。

## 继承

1. 继承关键字extends

2. 构造函数
   - 子类不继承父类构造函数，只是调用。
   - 如果父类构造函数有参数，则必须在子类构造器中显式通过super关键字调用父类的构造器，并且必须包含适当的参数列表（参数可多不可少）
   - 如果父类构造函数无参数，则在子类构造函数中不需要使用super调用，系统自动调用父类无参构造函数
   
3. protected关键字
   - private字段不可被子类访问
   - protected关键字把字段和方法的访问控制权限控制在继承树内部
   
4. 阻止继承

   ```
   java 15 允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称
   ```

5. 向上转型和向下转型（暂不考虑）

## 重写(Override)与重载(Overload)

### 方法签名

方法签名由方法名+形参列表构成；意思是方法名和形参数据类型列表可以唯一的确定一个方法

方法签名不同overload，overload是一个新方法；方法签名相同，返回值相同override

**注意：**方法名相同，方法参数相同，但是方法返回值不同，也是不同的方法。

### 方法的重写

- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，**但是必须是父类返回值的派生类**（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。

### 方法的重载

重载(overloading) **是在一个类里面，方法名字相同**，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是**构造器的重载**。

**重载规则**

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

## 多态

- 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。
- 多态存在的三个必要条件
  1. 继承
  2. 重写
  3. 父类引用指向子类对象
- 多态的实现方式
  1. 重写
  2. 借口
  3. 抽象类和抽象方法
- 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

## 抽象类

- 抽象类被设计成只能用于被继承，因此父类可以强迫子类必须实现其定义的抽象方法，否则编译报错，抽象方法实际相当于定义了“规范”
- 抽象类和抽象方法使用abstract修饰
- 子类必须声明为抽象类或者子类必须实现父类的抽象方法才可以继承抽象类
- 抽象类中的非抽象方法可以有方法体

### 面向抽象编程

- 当我们定义了抽象类`Person`，以及具体的`Student`、`Teacher`子类的时候，我们可以通过抽象类`Person`类型去引用具体的子类的实例

- 尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

- 面向抽象编程本质

  ```
  上层代码只定义规范（例如：abstract class Person）；
  
  不需要子类就可以实现业务逻辑（正常编译）；
  
  具体的业务逻辑由不同的子类实现，调用者并不关心。
  ```

## 接口

- 接口是抽象方法的集合，interface关键字声明，目的是被类实现

  接口内的方法默认pulic abstract

- 一个类可以实现多个接口，使用implements关键字

- 接口可以继承接口

- default方法

  ```
  default 方法目的：需要给接口新增一个方法时，会设计到修改全部子类，如果新增default方法，那么子类只需在需要重写的地方去扩展方法
  default方法需要有方法体
  ```

## 静态字段和静态方法

- 静态字段属于所有实例共享，实际是属于对应class的
- 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法
- 静态方法常用语工具类和辅助方法
- 推荐类名.静态字段（或静态方法）访问
- 接口是一个纯抽象类，不能定义实例字段，接口可以有静态字段，且为final类型，interface中的字段只能是public static final类型，可简写。

## 包

- 包的意义：为了防止命名冲突，访问控制，搜索定位
- IDEA右键创造包，包下边创造类，推荐命名方法：域名倒叙命名
- import导入不同包

## 核心类

### 字符串和编码

1. 字符串操作不改变原字符串内容，返回新字符串；

2. 常用字符串操作：比较、提取、查找、大小写转换，Java封装了很多处理字符串的函数。

3. Java使用Unicode编码表示String和char

4. 转换编码就是将string和byte[]转换，需要指定编码。

   ```java
   byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
   ```

5. 转换byte[] 时，始终优先考虑UTF-8编码

6. 字符串格式化

   ```java
   System.out.println(String.format("%s","fuck"));
   ```

### StringBuilder

- 循环拼接字符串，会循环创建对象销毁，浪费内存，影响效率
- StringBuilder 可以预分配缓冲区

### StringJoiner

- 分隔符拼接数组

